#!/usr/bin/env python

import os
import argparse
import tempfile
import shutil
import yaml
import argh
from argh import arg
import hubward

description = """
Command-line interface for hubward.
"""


@arg('dirname', help='Directory (or directories), each of which is '
     'expected to contain a metadata.yaml file or a '
     'metadata-builder.yaml file',
     nargs="+")
def study(dirname):
    """
    Process one or many studies.

    Each study's directory is expected to contain either:

        a file called metadata.yaml (in which case that file is used as-is)

            or

        a file called metadata-builder.py (in which case it is executed and is
        expected to create a metadata.yaml file).

    Each output file in the metadata.yaml file is considered up-to-date if it
    are newer than both the input file and the script that creates it.
    Otherwise, the script is run to update the output file.

    For creating a new study, see `hubward skeleton` which creates template
    files that can be filled in.
    """
    if isinstance(dirname, str):
        dirnames = [dirname]
    else:
        dirnames = dirname
    for dirname in dirnames:
        _study = hubward.models.Study(dirname)
        _study.process()


@arg('filename', help='Group config file')
def group(filename):
    """
    Process a group of studies configured in a group config file.

    This essentially calls `hubward process study <study name>` for each study
    in the group.
    """
    _group = hubward.models.Group(filename)
    _group.process()


@arg('filename', help='Group config file')
@arg('--hub-only', help='Just update the hub text files, not data files')
def upload(filename, hub_only=False):
    """
    Creates a track hub and uploads to configured host.

    Track hub files include hub.txt, genomes.txt, and trackDb.txt files. If
    --hub-only has been specified, only these files will be uploaded to the
    host configured in the group config file.

    Otherwise, these files and all of the configured data files (bigBed,
    bigWig, BAM, and VCF files) from individual studies are uploaded via rsync
    to their respective configured locations on the remote host.
    """
    _group = hubward.models.Group(filename)
    _group.upload(hub_only=hub_only)


@arg('dirname', help='Single study to liftover')
@arg('newdir', help='Destination directory')
@arg('--from_assembly', help='Source assembly')
@arg('--to_assembly', help='Destination assembly')
def liftover(dirname, newdir, from_assembly=None, to_assembly=None):
    """
    Lift over coordinates from one assembly to another, in bulk.

    For all configured tracks in <dirname>/metadata.yaml, if the configured
    track genome matches <from_assembly> then perform the liftover to
    a temporary directory and then move the result to <newdir> when complete.

    If a track's genome does not match <from_assembly>, then that file is
    copied as-is to <newdir>.

    The genome field of each track is also edited to reflect the new genome,
    and a symlink called ORIGINAL-STUDY is placed in <newdir>. In the end,
    a complete version of <dirname> is available in <newdir> with appropriate
    tracks lifted over to the new assembly.

    Note: this uses CrossMap (http://crossmap.sourceforge.net) which currently
    only runs in Python 2.7.
    """
    _study = hubward.models.Study(dirname)
    dirname = dirname.rstrip(os.path.sep)
    newdir = newdir.rstrip(os.path.sep)

    # First process everything into a temporary directory
    tmpdir = tempfile.mkdtemp()
    for d in _study.data:
        infile = d.processed
        outfile = d.processed.replace(dirname, newdir)
        d.liftover(from_assembly, to_assembly, outfile)

    with open(os.path.join(newdir, 'metadata.yaml'), 'w') as fout:
        hubward.log('Writing new metadata to {0}'.format(fout.name))
        yaml.dump(_study.metadata, fout)

    symlink = os.path.join(newdir, 'ORIGINAL-STUDY')
    if os.path.exists(symlink):
        os.unlink(symlink)
    os.symlink(os.path.abspath(dirname), symlink)


@arg('dirname', help='Path to contain skeleton project')
@arg('--use-metadata-builder', help='Sets up a metadata-builder.py script '
     'instead of a metadata.yaml config file. Useful for more complicated '
     'studies')
def skeleton(dirname, use_metadata_builder=False):
    """
    Populate <dirname> with template files that can be customized on
    a per-study basis.
    """
    if os.path.exists(dirname):
        raise ValueError("Directory {0} exists. Aborting!".format(dirname))

    os.makedirs(dirname)
    if use_metadata_builder:
        with open(os.path.join(dirname, 'metadata-builder.py'), 'w') as fout:
            fout.write(
                hubward.utils.get_resource('metadata_builder_template.py'))
    else:
        metadata_schema = hubward.utils.get_resource(
            'metadata_schema.yaml', as_tempfile=True)
        with open(os.path.join(dirname, 'metadata.yaml'), 'w') as fout:
            hubward.generate_config_from_schema.create_config(
                metadata_schema, fout)

    group_schema = hubward.utils.get_resource(
        'group_schema.yaml', as_tempfile=True)
    with open(os.path.join(dirname, 'example-group.yaml'), 'w') as fout:
        hubward.generate_config_from_schema.create_config(
            group_schema, fout)

    with open(os.path.join(dirname, 'README.rst'), 'w') as fout:
        fout.write('Description of study and necessary processing steps\n')


parser = argparse.ArgumentParser(description=description)
argh.add_commands(parser, [study, group], namespace='process')
argh.add_commands(parser, [upload, liftover, skeleton])

if __name__ == "__main__":
    argh.dispatch(parser)
